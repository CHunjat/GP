/*
*  작성일 : 2025 2 20
*  작성자 : 나
* 주제 : 데이터 표현 방식
*/

/*
* 2가지의 타입 : 정수, 실수 +문자(숫자) 약속
* int, char, short, long longlong - 정수
* float, double, decimal - 실수
* 
* (사람 - 사람) , (컴퓨터 - 사람) int 어떻게 이해를 할까?
* int 변수이름; 변수이름 녀석이 정수형태의 값을 받을 수 있다. + 얼마만큼 데이터 저장 크기를 지정
* 
*/

/*
* 정수를 표현하는 방법
* - 표현하는 키워드가 많다.
* - 이유 : 최선의 메모리를 사용하기 위해서.
* - 기본 단위 정보를 읽는 기본 단위 : 바이트 = 8 비트
* - 비트 ㅁ(0,1)
* 
* char(1ro), short(2ro), int(4) -> 일반적인표현 컴파일적으로 다르면 다를수 있음.
* 10진법 -> 2진법 
* 16  -> 2진법은 : 0000 1000 = 2^4x1
* 127 -> 2진법은 : 00111111 
* 
* int attackpower; 00000000,00000000,00000000,00000000;
* char ch1;                                   00000000;
* 
*   0000 0000 2^8 = 256 
* 
* 
*/

/*
* 뺄셈 : A-B = A+ (-B)
* 정수 : 음수를 표현하는 방법
* MSB : Most Signmant Bit 
* 데이터 표현방식에서 가장 왼쪽끝 "0"0000000 에 있는 비트에 할당한다.
* 
* 5를 양수로 표현 00000101 2^2*1 +2^0*1 = 4+1 =5
* -5 비트로 어떻게 표현할까 10000101 
* byte로 표현하면 10000101 은 뭘까
*                                           99
*                                           99
*                                           198
* 
* 2의 보수법 - 양수를 비트로 표현합니다. 모든 비트를 반전시킨다 +1 ; 
*                           00000101 2^7(128) 2^8(256)
*                           11111010
*                           11111111
*                           +      1
*                      1    00000000
*                              
* * 5 +(-5) = 0 
* 
* 메모리 측면, 
* unsigned int 부호비트를 부호로 쓰지않고 데이터로 쓴다, 음수를 사용안하겠다는 뜻.
* 
* 
* 컴퓨터는 데이터 타입이 다르면 문제가 생길수도 있구나!
* 문제가 생겼을 때 어떻게 해결하면 될까?
* 어떤 방식으로 문제를 해결하고 있을가?
* 
*/

/*
* 실수를 표현하는 방식
*
* 2바이트  00000000 00000000
* 8 8 (절반은 정수, 절반은 실수)
* 00000101 00000101 - > 5.5
* 
* 위에거는 5.4955 // 표현하고자 하는 수가 얼마 차이 나지 않는다. 실수를 표현하는 비트의 수가 너무적다.
* 실수를 표현할 수 있는 범위가 너무 적다.
* 
* 부동소수점 방식 : float 둥둥떠다니다, 
* 
* 
* 125.234091 
* 
* 정규화된식^(지수)
* 어떤 수를 제곱, 1;
* 33^0 = 1
* 0
* 
* 
* 0 <   < 10 사이의 수로 표현.
* 0.2334
* 
* 부동소수점의 오차가 발생한다.
* 1 = 1.0 컴퓨터에서 다르다
* why? < 이걸 설명하는거임. 
* 
*/


/*
	int attackpower = 10 + 1 * 0.3;

	리터럴 상수
	int, double    - int형 정의, double 형 정의
	1 * 0.3;  11.3

	int 정의=> 0 
	double 정의 => 0.3
	반드시 손실이 발생. -> 데이터 날라감
	이유 - > double 11 + 0.3 


*/


/*
* 
* 데이터 형 -> 스스로 형태를 바꾸고 있다.
* 형 변환 
* - 자동 : 묵시적 변환
* - 수동 : 명시적 변환 
* 
* 
*/


#include <stdio.h>

int main()
{
	int attackpower = 10 + 1 * 0.3;
	double attackpower2 = 10 + 1 * 0.3; // 10.3
	printf("값 ; %lf", attackpower2); // 정수 표현 방식의 값으로 읽어온다.

	printf("정수의 표현 방식 실습\n");

	char num1 = 129+60; // 0000 0000
	                 // 0111 1111 127
	                 // 1000 0001 

	int num2 = 129;    // () () () 1000 0001
	char num3 = num2;  // () () () 

	printf("값 :%d\n", num1);

	printf("실수의 표현방식 실습\n");

	float num4 = 0.1;

	for(int i=0; i<1000; i++)
	num4 += 0.1;

	printf("값 : %f", num4);



}